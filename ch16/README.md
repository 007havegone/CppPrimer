# Chapter 16. Templates and Generic Programming

## Exercise 16.1

> Define instantiation.

Class or function generated by the compiler from a template.

## Exercise 16.2

> Write and test your own versions of the `compare` functions.

[compare](ex16_02_compare.h)

## Exercise 16.3

> Call your `compare` function on two `Sales_data` objects to see how your compiler handles errors during instantiation.

```sh
error C2678: binary '<': no operator found which takes a left-hand operand of type 'const Sales_data' (or there is no acceptable conversion)
```

## Exercise 16.4

> Write a template that acts like the library `find` algorithm. The function will need two template type parameters, one to represent the function’s iterator parameters and the other for the type of the value. Use your function to find a given value in a `vector<int>` and in a `list<string>`.

[Find](ex16_04_find.h)

## Exercise 16.5

> Write a template version of the `print` function from 6.2.4 (p. 217) that takes a reference to an array and can handle arrays of any size and any element type.

[print](ex16_05_print_array.h)

## Exercise 16.6

> How do you think the library `begin` and `end` functions that take an array argument work? Define your own versions of these functions.

[begin and end](ex16_06_begin_end.h)

## Exercise 16.7

> Write a `constexpr` template that returns the size of a given array.

[SizeOfArray](ex16_07_sizeof_array.h)

## Exercise 16.8

> In the “Key Concept” box on page 108, we noted that as a matter of habit C++ programmers prefer using != to using <. Explain the rationale for this habit.

As we’ve seen, only a few library types, `vector` and `string` being among them, have the subscript operator. Similarly, all of the library containers have iterators that define the `==` and `!=` operators. Most of those iterators do not have the `<` operator. By routinely using iterators and `!=`, we don’t have to worry about the precise type of container we’re processing.

## Exercise 16.9

> What is a function template? What is a class template?

- function template: Definition from which specific functions can be instantiated.
- class template: Definition from which specific classes can be instantiated.
- differ: the compiler cannot deduce the template parameter type(s) like function templates for a class template. we should supply the list of template arguments to use in place of the template parameters inside angle brackets following the template's name.

## Exercise 16.10

> What happens when a class template is instantiated?

the compiler **rewrites** the class template, **replacing each instance** of the template parameter `T` by the given template argument.

## Exercise 16.11

> The following definition of `List` is incorrect. How would you fix it?
>
> ```cpp
> template <typename elemType> class ListItem;
> template <typename elemType> class List {
> public:
>   List<elemType>();
>   List<elemType>(const List<elemType> &);
>   List<elemType>& operator=(const List<elemType> &);
>   ~List();
>   void insert(ListItem *ptr, elemType value);
> private:
>   ListItem *front, *end;
> };
> ```

use of class template `ListItem` requires template arguments.

```cpp
void insert(ListItem<elemType> *ptr, elemType value);
ListItem<elemType> *front, *end;
```

## Exercise 16.12

> Write your own version of the `Blob` and `BlobPtr` templates. including the various `const` members that were not shown in the text.

[`Blob`, `BlobPtr` and `ConstBlobPtr`](ex16_12_blob.h) | [Test](ex16_12_blob_test.cpp)

## Exercise 16.13

> Explain which kind of friendship you chose for the equality and relational operators for `BlobPtr`.

General friendship that each instantiation of `BlobPtr` grants access to the version of the equality and relational operators instantiated with the same type.

## Exercise 16.14

> Write a `Screen` class template that uses nontype parameters to define the height and width of the `Screen`.

[Screen](ex16_14_screen.h) | [Test](ex16_14_screen_test.cpp)

## Exercise 16.15

> Implement input and output operators for your `Screen` template. Which, if any, friends are necessary in class `Screen` to make the input and output operators work? Explain why each friend declaration, if any, was needed.

[Screen](ex16_14_screen.h) | [Test](ex16_14_screen_test.cpp)

same reason with `Blob`.

## Exercise 16.16

> Rewrite the `StrVec` class (§ 13.5, p. 526) as a template named `Vec`.

[Vec](ex16_16_vec.h) | [Test](ex16_16_vec_test.cpp)

## Exercise 16.17

> What, if any, are the differences between a type parameter that is declared as a `typename` and one that is declared as a `class`? When must `typename` be used?

When we want to inform the compiler that a name represents a type, we must use the keyword `typename`, not `class`.

## Exercise 16.18

> Explain each of the following function template declarations and identify whether any are illegal. Correct each error that you find.
>
> ```cpp
> (a) template <typename T, U, typename V> void f1(T, U, V);
> (b) template <typename T> T f2(int &T);
> (c) inline template <typename T> T foo(T, unsigned int*);
> (d) template <typename T> f4(T, T);
> (e) typedef char Ctype;
> template <typename Ctype> Ctype f5(Ctype a);
> ```

Fixed:

```cpp
(a) template <typename T, typename U, typename V> void f1(T, U, V); // identifier 'U'
(b) template <typename T> T f2(int &); // typename would be hidden
(c) template <typename T> inline T foo(T, unsigned int*); // inline must be after template
(d) template <typename T> void f4(T, T); // return type should be provided
(e) typedef char Ctype;
template <typename T> T f5(Ctype a); // the typename hides this typedef
```

## Exercise 16.19

> Write a function that takes a reference to a container and prints the elements in that container. Use the container’s `size_type` and `size` members to control the loop that prints the elements.

[print](ex16_19_print_container.cpp)

## Exercise 16.20

> Rewrite the function from the previous exercise to use iterators returned from `begin` and `end` to control the loop.

[print](ex16_20_print_container_iter.cpp)

## Exercise 16.21

> Write your own version of `DebugDelete`.

[DebugDelete|h](ex16_21_debugdelete.h) | [DebugDelete|cpp](ex16_21_debugdelete.cpp)

## Exercise 16.22

> Revise your `TextQuery` programs from 12.3 (p. 484) so that the `shared_ptr` members use a `DebugDelete` as their deleter (12.1.4, p. 468).

[TestQuery|h](ex16_22_textquery.h) | [TestQuery|cpp](ex16_22_textquery.cpp) | [TestQuery|test](ex16_22_textquery_test.cpp)

## Exercise 16.23

> Predict when the call operator will be executed in your main query program. If your expectations and what happens differ, be sure you understand why.

when input the `q` to quit `runQueries` function. [Exercise 16.22](#exercise-1622)'s output can check this.

## Exercise 16.24

> Add a constructor that takes two iterators to your `Blob` template.

[Blob|h](ex16_24_blob.h) | [Blob|test](ex16_24_blob_test.cpp)

## Exercise 16.25

> Explain the meaning of these declarations
>```cpp
>extern template class vector<string>;
>template class vector<Sales_data>;
>```

`vector<string>` instantiation declaration here, it must be instantiated elsewhere in the program.
`vector<Sales_data>` instantiates all members of the class template here.

## Exercise 16.26

> Assuming `NoDefault` is a class that does not have a default constructor, can we explicitly instantiate `vector<NoDefault>`? If not, why not?

see <https://stackoverflow.com/questions/21525169/while-explicitly-instantiating-vectorsometype-what-is-the-sometype-default-co>

## Exercise 16.27

> For each labeled statement explain what, if any, instantiations happen. If a template is instantiated, explain why; if not, explain why not.
>```cpp
>template <typename T> class Stack { };
>
>void f1(Stack<char>);                   // (a)
>class Exercise {
>    Stack<double> &rsd;                 // (b)
>    Stack<int>    si;                   // (c)
>};
>int main() {
>    Stack<char> *sc;                    // (d)
>    f1(*sc);                            // (e)
>    int iObj = sizeof(Stack< string >); // (f)
>}
>```

Solution:

- (a) No instantiation, compiles, it got instantiated when called.
- (b) No instantiation, compiles, references and pointers doesn't need instantiation
- (c) Instantiation. Doesn't compile!
- (d) No instantiation, compiles, references and pointers doesn't need instantiation
- (e) Instantiation of `Stack<char>`. Doesn't compile!
- (f) Instantiation of `Stack<std::string>`. Doesn't compileNo instantiation, compiles, references and pointers doesn't need instantiation!

Solution from [How is a template instantiated? - Stack Overflow](https://stackoverflow.com/questions/21598635/how-is-a-template-instantiated)

## Exercise 16.28

> Write your own versions of `shared_ptr` and `unique_ptr`.

## Exercise 16.29

> Revise your `Blob` class to use your version of `shared_ptr` rather than the library version.

## Exercise 16.30

Rerun some of your programs to verify your `shared_ptr` and revised `Blob` classes. (Note: Implementing the `weak_ptr` type is beyond the scope of this Primer, so you will not be able to use the `BlobPtr`
class with your revised `Blob`.)

## Exercise 16.31

>Explain how the compiler might inline the call to the deleter if we used `DebugDelete` with `unique_ptr`.